{
  "version": 3,
  "sources": ["../../three/examples/jsm/tsl/display/SSAAPassNode.js"],
  "sourcesContent": ["import { AdditiveBlending, Color, Vector2, RendererUtils, PassNode, QuadMesh, NodeMaterial } from 'three/webgpu';\nimport { nodeObject, uniform, mrt, texture, getTextureIndex } from 'three/tsl';\n\n/** @module SSAAPassNode **/\n\nconst _size = /*@__PURE__*/ new Vector2();\n\nlet _rendererState;\n\n/**\n * A special render pass node that renders the scene with SSAA (Supersampling Anti-Aliasing).\n * This manual SSAA approach re-renders the scene ones for each sample with camera jitter and accumulates the results.\n *\n * This node produces a high-quality anti-aliased output but is also extremely expensive because of\n * its brute-force approach of re-rendering the entire scene multiple times.\n *\n * Reference: {@link https://en.wikipedia.org/wiki/Supersampling}\n *\n * @augments PassNode\n */\nclass SSAAPassNode extends PassNode {\n\n\tstatic get type() {\n\n\t\treturn 'SSAAPassNode';\n\n\t}\n\n\t/**\n\t * Constructs a new SSAA pass node.\n\t *\n\t * @param {Scene} scene - The scene to render.\n\t * @param {Camera} camera - The camera to render the scene with.\n\t */\n\tconstructor( scene, camera ) {\n\n\t\tsuper( PassNode.COLOR, scene, camera );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isSSAAPassNode = true;\n\n\t\t/**\n\t\t * The sample level specified  as n, where the number of samples is 2^n,\n\t\t * so sampleLevel = 4, is 2^4 samples, 16.\n\t\t *\n\t\t * @type {Number}\n\t\t * @default 4\n\t\t */\n\t\tthis.sampleLevel = 4;\n\n\t\t/**\n\t\t * Whether rounding errors should be mitigated or not.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.unbiased = true;\n\n\t\t/**\n\t\t * The clear color of the pass.\n\t\t *\n\t\t * @type {Color}\n\t\t * @default 0x000000\n\t\t */\n\t\tthis.clearColor = new Color( 0x000000 );\n\n\t\t/**\n\t\t * The clear alpha of the pass.\n\t\t *\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t */\n\t\tthis.clearAlpha = 0;\n\n\t\t/**\n\t\t * A uniform node representing the sample weight.\n\t\t *\n\t\t * @type {UniformNode<float>}\n\t\t * @default 1\n\t\t */\n\t\tthis.sampleWeight = uniform( 1 );\n\n\t\t/**\n\t\t * Reference to the internal render target that holds the current sample.\n\t\t *\n\t\t * @private\n\t\t * @type {RenderTarget?}\n\t\t */\n\t\tthis._sampleRenderTarget = null;\n\n\t\t/**\n\t\t * Reference to the internal quad mesh.\n\t\t *\n\t\t * @private\n\t\t * @type {QuadMesh}\n\t\t */\n\t\tthis._quadMesh = new QuadMesh();\n\n\t}\n\n\t/**\n\t * This method is used to render the SSAA effect once per frame.\n\t *\n\t * @param {NodeFrame} frame - The current node frame.\n\t */\n\tupdateBefore( frame ) {\n\n\t\tconst { renderer } = frame;\n\t\tconst { scene, camera } = this;\n\n\t\t_rendererState = RendererUtils.resetRendererAndSceneState( renderer, scene, _rendererState );\n\n\t\t//\n\n\t\tthis._pixelRatio = renderer.getPixelRatio();\n\n\t\tconst size = renderer.getSize( _size );\n\n\t\tthis.setSize( size.width, size.height );\n\t\tthis._sampleRenderTarget.setSize( this.renderTarget.width, this.renderTarget.height );\n\n\t\t//\n\n\t\tthis._cameraNear.value = camera.near;\n\t\tthis._cameraFar.value = camera.far;\n\n\t\trenderer.setMRT( this.getMRT() );\n\t\trenderer.autoClear = false;\n\n\t\tconst jitterOffsets = _JitterVectors[ Math.max( 0, Math.min( this.sampleLevel, 5 ) ) ];\n\n\t\tconst baseSampleWeight = 1.0 / jitterOffsets.length;\n\t\tconst roundingRange = 1 / 32;\n\n\t\tconst viewOffset = {\n\n\t\t\tfullWidth: this.renderTarget.width,\n\t\t\tfullHeight: this.renderTarget.height,\n\t\t\toffsetX: 0,\n\t\t\toffsetY: 0,\n\t\t\twidth: this.renderTarget.width,\n\t\t\theight: this.renderTarget.height\n\n\t\t};\n\n\t\tconst originalViewOffset = Object.assign( {}, camera.view );\n\n\t\tif ( originalViewOffset.enabled ) Object.assign( viewOffset, originalViewOffset );\n\n\t\t// render the scene multiple times, each slightly jitter offset from the last and accumulate the results.\n\n\t\tfor ( let i = 0; i < jitterOffsets.length; i ++ ) {\n\n\t\t\tconst jitterOffset = jitterOffsets[ i ];\n\n\t\t\tif ( camera.setViewOffset ) {\n\n\t\t\t\tcamera.setViewOffset(\n\n\t\t\t\t\tviewOffset.fullWidth, viewOffset.fullHeight,\n\n\t\t\t\t\tviewOffset.offsetX + jitterOffset[ 0 ] * 0.0625, viewOffset.offsetY + jitterOffset[ 1 ] * 0.0625, // 0.0625 = 1 / 16\n\n\t\t\t\t\tviewOffset.width, viewOffset.height\n\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t\tthis.sampleWeight.value = baseSampleWeight;\n\n\t\t\tif ( this.unbiased ) {\n\n\t\t\t\t// the theory is that equal weights for each sample lead to an accumulation of rounding errors.\n\t\t\t\t// The following equation varies the sampleWeight per sample so that it is uniformly distributed\n\t\t\t\t// across a range of values whose rounding errors cancel each other out.\n\n\t\t\t\tconst uniformCenteredDistribution = ( - 0.5 + ( i + 0.5 ) / jitterOffsets.length );\n\t\t\t\tthis.sampleWeight.value += roundingRange * uniformCenteredDistribution;\n\n\t\t\t}\n\n\t\t\trenderer.setClearColor( this.clearColor, this.clearAlpha );\n\t\t\trenderer.setRenderTarget( this._sampleRenderTarget );\n\t\t\trenderer.clear();\n\t\t\trenderer.render( scene, camera );\n\n\t\t\t// accumulation\n\n\t\t\trenderer.setRenderTarget( this.renderTarget );\n\n\t\t\tif ( i === 0 ) {\n\n\t\t\t\trenderer.setClearColor( 0x000000, 0.0 );\n\t\t\t\trenderer.clear();\n\n\t\t\t}\n\n\t\t\tthis._quadMesh.render( renderer );\n\n\t\t}\n\n\t\trenderer.copyTextureToTexture( this._sampleRenderTarget.depthTexture, this.renderTarget.depthTexture );\n\n\t\t// restore\n\n\t\tif ( camera.setViewOffset && originalViewOffset.enabled ) {\n\n\t\t\tcamera.setViewOffset(\n\n\t\t\t\toriginalViewOffset.fullWidth, originalViewOffset.fullHeight,\n\n\t\t\t\toriginalViewOffset.offsetX, originalViewOffset.offsetY,\n\n\t\t\t\toriginalViewOffset.width, originalViewOffset.height\n\n\t\t\t);\n\n\t\t} else if ( camera.clearViewOffset ) {\n\n\t\t\tcamera.clearViewOffset();\n\n\t\t}\n\n\t\t//\n\n\t\tRendererUtils.restoreRendererAndSceneState( renderer, scene, _rendererState );\n\n\t}\n\n\t/**\n\t * This method is used to setup the effect's MRT configuration and quad mesh.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {PassTextureNode}\n\t */\n\tsetup( builder ) {\n\n\t\tif ( this._sampleRenderTarget === null ) {\n\n\t\t\tthis._sampleRenderTarget = this.renderTarget.clone();\n\n\t\t}\n\n\t\tlet sampleTexture;\n\n\t\tconst passMRT = this.getMRT();\n\n\t\tif ( passMRT !== null ) {\n\n\t\t\tconst outputs = {};\n\n\t\t\tfor ( const name in passMRT.outputNodes ) {\n\n\t\t\t\tconst index = getTextureIndex( this._sampleRenderTarget.textures, name );\n\n\t\t\t\tif ( index >= 0 ) {\n\n\t\t\t\t\toutputs[ name ] = texture( this._sampleRenderTarget.textures[ index ] ).mul( this.sampleWeight );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tsampleTexture = mrt( outputs );\n\n\t\t} else {\n\n\t\t\tsampleTexture = texture( this._sampleRenderTarget.texture ).mul( this.sampleWeight );\n\n\t\t}\n\n\t\tthis._quadMesh.material = new NodeMaterial();\n\t\tthis._quadMesh.material.fragmentNode = sampleTexture;\n\t\tthis._quadMesh.material.transparent = true;\n\t\tthis._quadMesh.material.depthTest = false;\n\t\tthis._quadMesh.material.depthWrite = false;\n\t\tthis._quadMesh.material.premultipliedAlpha = true;\n\t\tthis._quadMesh.material.blending = AdditiveBlending;\n\t\tthis._quadMesh.material.name = 'SSAA';\n\n\t\treturn super.setup( builder );\n\n\t}\n\n\t/**\n\t * Frees internal resources. This method should be called\n\t * when the pass is no longer required.\n\t */\n\tdispose() {\n\n\t\tsuper.dispose();\n\n\t\tif ( this._sampleRenderTarget !== null ) {\n\n\t\t\tthis._sampleRenderTarget.dispose();\n\n\t\t}\n\n\t}\n\n}\n\nexport default SSAAPassNode;\n\n// These jitter vectors are specified in integers because it is easier.\n// I am assuming a [-8,8) integer grid, but it needs to be mapped onto [-0.5,0.5)\n// before being used, thus these integers need to be scaled by 1/16.\n//\n// Sample patterns reference: https://msdn.microsoft.com/en-us/library/windows/desktop/ff476218%28v=vs.85%29.aspx?f=255&MSPPError=-2147217396\nconst _JitterVectors = [\n\t[\n\t\t[ 0, 0 ]\n\t],\n\t[\n\t\t[ 4, 4 ], [ - 4, - 4 ]\n\t],\n\t[\n\t\t[ - 2, - 6 ], [ 6, - 2 ], [ - 6, 2 ], [ 2, 6 ]\n\t],\n\t[\n\t\t[ 1, - 3 ], [ - 1, 3 ], [ 5, 1 ], [ - 3, - 5 ],\n\t\t[ - 5, 5 ], [ - 7, - 1 ], [ 3, 7 ], [ 7, - 7 ]\n\t],\n\t[\n\t\t[ 1, 1 ], [ - 1, - 3 ], [ - 3, 2 ], [ 4, - 1 ],\n\t\t[ - 5, - 2 ], [ 2, 5 ], [ 5, 3 ], [ 3, - 5 ],\n\t\t[ - 2, 6 ], [ 0, - 7 ], [ - 4, - 6 ], [ - 6, 4 ],\n\t\t[ - 8, 0 ], [ 7, - 4 ], [ 6, 7 ], [ - 7, - 8 ]\n\t],\n\t[\n\t\t[ - 4, - 7 ], [ - 7, - 5 ], [ - 3, - 5 ], [ - 5, - 4 ],\n\t\t[ - 1, - 4 ], [ - 2, - 2 ], [ - 6, - 1 ], [ - 4, 0 ],\n\t\t[ - 7, 1 ], [ - 1, 2 ], [ - 6, 3 ], [ - 3, 3 ],\n\t\t[ - 7, 6 ], [ - 3, 6 ], [ - 5, 7 ], [ - 1, 7 ],\n\t\t[ 5, - 7 ], [ 1, - 6 ], [ 6, - 5 ], [ 4, - 4 ],\n\t\t[ 2, - 3 ], [ 7, - 2 ], [ 1, - 1 ], [ 4, - 1 ],\n\t\t[ 2, 1 ], [ 6, 2 ], [ 0, 4 ], [ 4, 4 ],\n\t\t[ 2, 5 ], [ 7, 5 ], [ 5, 6 ], [ 3, 7 ]\n\t]\n];\n\n/**\n * TSL function for creating a SSAA pass node for Supersampling Anti-Aliasing.\n *\n * @function\n * @param {Scene} scene - The scene to render.\n * @param {Camera} camera - The camera to render the scene with.\n * @returns {SSAAPassNode}\n */\nexport const ssaaPass = ( scene, camera ) => nodeObject( new SSAAPassNode( scene, camera ) );\n"],
  "mappings": "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",
  "names": []
}
